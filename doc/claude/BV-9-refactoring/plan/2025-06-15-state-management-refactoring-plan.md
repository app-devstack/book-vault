# 状態管理リファクタリング計画

**作成日**: 2025年6月15日
**対象**: Book-Vault アプリの状態管理アーキテクチャ改善

## 背景

現在のBooksProviderは役割が大きすぎて、以下の問題を抱えている：

1. **過度な集約**: 全画面の状態を一元管理している
2. **不要な再レンダリング**: 関係ない画面まで状態変更の影響を受ける
3. **複雑性の増大**: 単一プロバイダーに多すぎる責務が集約されている

## 新しい状態管理戦略

### 基本方針

Expo Routerの画面ベース構造に合わせて、状態管理を適切に分散させる。アプリ全体で本の情報を管理する必要性を見直し、画面固有の状態管理を中心とした設計に移行する。

### 画面固有の状態管理

各画面で必要な状態のみを管理し、React QueryとuseStateを適切に使い分ける：

#### 登録画面（Book Registration）

- **管理対象**: フォーム状態、バリデーション結果
- **実装**: `useState` + React Hook Form
- **理由**: 一時的なフォーム状態なので画面内で完結

#### 検索画面（Search）

- **管理対象**: 検索結果、フィルター設定、ページネーション
- **実装**: `useState` + React Query
- **理由**: Google Books APIからのデータはReact Queryでキャッシュ管理

#### 詳細画面（Book Detail）

- **管理対象**: 個別の本データ、編集状態
- **実装**: React Query
- **理由**: データベースからの取得とキャッシュが必要

#### シリーズ画面（Series）

- **管理対象**: シリーズ一覧、ソート設定、フィルター
- **実装**: `useState` + React Query
- **理由**: ローカルUIステートとサーバーステートの組み合わせ

### 最小限のグローバル状態

真にアプリ全体で共有が必要な状態のみをグローバルで管理：

#### 必要なグローバル状態

- **認証状態**: ユーザー情報（将来的に追加される場合）
- **アプリ設定**: テーマ、言語設定、表示設定
- **通知システム**: トースト、エラーメッセージ、ローディング状態

#### 不要になるグローバル状態

- **全書籍データ**: 画面ごとに必要分のみ取得
- **検索結果**: 検索画面でのみ管理
- **フォーム状態**: 各フォーム画面で管理

### React Queryの活用強化

#### サーバー状態の統一管理

- **Google Books API**: 検索結果、書籍メタデータ
- **ローカルSQLite**: Drizzle ORMを通じたデータアクセス

#### キャッシュ戦略

- **画面間データ共有**: React Queryのキャッシュ機能を活用
- **バックグラウンド更新**: stale-while-revalidate戦略
- **楽観的更新**: ユーザビリティ向上のための即座のUI反映

## 実装アプローチ

### 段階的移行

1. **Phase 1**: 新しい画面固有フックの作成
2. **Phase 2**: 既存画面の段階的移行
3. **Phase 3**: BooksProviderの段階的縮小
4. **Phase 4**: 不要なグローバル状態の削除

### 品質保証

- 各段階でテストを実行し動作確認
- 型安全性を維持
- パフォーマンスの改善を測定

## 期待される効果

### パフォーマンス向上

- 不要な再レンダリングの削減
- メモリ使用量の最適化
- 画面遷移の高速化

### 開発体験向上

- 画面固有の状態が見つけやすくなる
- デバッグの容易性向上
- 新機能追加時の影響範囲の明確化

### 保守性向上

- 責務の明確な分離
- テストしやすい構造
- 将来的な機能追加への対応力向上

---

## TODO

### Phase 1: 設計・準備 (1-2日)

- [ ] 現在のBooksProviderの責務を詳細に分析
- [ ] 各画面で実際に必要な状態を洗い出し
- [ ] React Query設定の見直し・最適化
- [ ] 新しい画面固有フックの設計書作成

### Phase 2: 画面固有フックの実装 (3-4日)

- [ ] `useBookRegistration` フックの作成（登録画面用）
- [ ] `useBookSearch` フックの作成（検索画面用）
- [ ] `useBookDetail` フックの作成（詳細画面用）
- [ ] `useSeriesList` フックの作成（シリーズ画面用）
- [ ] 各フックの単体テスト作成

### Phase 3: 画面の段階的移行 (4-5日)

- [ ] 登録画面をuseBookRegistrationに移行
- [ ] 検索画面をuseBookSearchに移行
- [ ] 詳細画面をuseBookDetailに移行
- [ ] シリーズ画面をuseSeriesListに移行
- [ ] 各画面の動作確認とテスト実行

### Phase 4: グローバル状態の整理 (2-3日)

- [ ] 不要になったBooksProviderの機能を特定
- [ ] 必要最小限のグローバル状態を新しいProviderに移行
- [ ] 旧BooksProviderの段階的削除
- [ ] 全体的な動作確認

### Phase 5: 最適化・クリーンアップ (1-2日)

- [ ] 未使用コードの削除
- [ ] 型定義の整理
- [ ] パフォーマンステスト実行
- [ ] ドキュメント更新（CLAUDE.md）

### Phase 6: 品質保証 (1日)

- [ ] 全機能のE2Eテスト実行
- [ ] リファクタリング効果の測定
- [ ] コードレビューとベストプラクティス確認
