# useBooksリファクタリング計画

## 現状の分析

`useBooks`フックは現在400行以上の巨大なフックとなっており、以下の多くの責任を一手に担っている：

- **データ管理**: books配列、emptySeries配列、統計情報の管理
- **ローディング状態管理**: 複数のローディング状態を管理
- **エラーハンドリング**: エラーの発生、処理、リトライ機能
- **CRUD操作**: 書籍・シリーズの作成、読み込み、更新、削除
- **一括操作**: 複数の書籍に対する操作
- **アンドゥ機能**: 操作の取り消し機能
- **データ変換**: booksからseriesedBooksへの変換処理
- **確認ダイアログ**: 削除確認等のUI表示制御

この単一責任の原則に反する設計により、以下の問題が発生している：

- **テストの困難さ**: 巨大なフックのテストは複雑
- **保守性の低下**: 機能追加・修正時の影響範囲が予測しにくい
- **再利用性の欠如**: 特定の機能のみ利用したい場合でも全体を使う必要がある
- **認知負荷の高さ**: コードを理解するのに時間がかかる

## 解決すべき課題

1. **単一責任の原則違反**: 複数の関心事を一つのフックで管理
2. **コードの可読性低下**: 400行超のコードは把握が困難
3. **テスタビリティの欠如**: 機能別のテストが困難
4. **結合度の高さ**: 各機能が密結合している
5. **拡張性の問題**: 新機能追加時の影響範囲が広い

## 解決案（おすすめ順）

### 1. 機能別フック分割 + Compositionパターン（最推奨）

**概要**: 責任別に複数のフックに分割し、メインフックで組み合わせる

```typescript
// 分割後の構造
useBookData()          // データ管理・取得
useBookMutations()     // CRUD操作
useBulkOperations()    // 一括操作
useUndoOperations()    // アンドゥ機能
useErrorHandler()      // エラーハンドリング
useLoadingStates()     // ローディング状態管理

// メインフック
useBooks() // 上記を組み合わせて公開APIを提供
```

**メリット**:

- 各フックが単一責任を持つ
- テストが容易
- 必要な機能のみ個別利用可能
- 段階的な移行が可能

**デメリット**:

- 初期実装コストが高い
- フック間の依存関係の管理が必要

## 使い勝手向上のための意識すべきポイント

### 1. **明確なAPI設計**

- フックが提供する機能を明確にドキュメント化
- 戻り値の構造を一貫性のあるものにする
- TypeScriptの型定義を充実させる

### 2. **エラーハンドリングの標準化**

- エラーの種類と対処法を明確にする
- ユーザーフレンドリーなエラーメッセージを提供
- リトライ機能の統一的な実装

### 3. **パフォーマンス最適化**

- メモ化の適切な使用
- 不要な再レンダリングの防止
- 大量データ処理時の最適化

### 4. **開発者体験の向上**

- ESLintルールの追加
- 豊富なJSDocコメント
- 使用例とベストプラクティスの文書化

### 5. **テスタビリティの確保**

- 各機能の単体テストを容易にする設計
- モック化しやすいインターフェース
- 副作用の分離

### 6. **段階的移行戦略**

- 既存コードへの影響を最小限に抑える
- 後方互換性の維持
- 移行ガイドラインの作成

## 推奨実装順序

1. **フェーズ1**: エラーハンドリングとローディング状態の分離
2. **フェーズ2**: CRUD操作の独立したフック化
3. **フェーズ3**: 一括操作とアンドゥ機能の分離
4. **フェーズ4**: データ変換ロジックの最適化
5. **フェーズ5**: 統合テストとドキュメント整備

この計画により、保守性・テスタビリティ・拡張性の大幅な向上が期待できます。
